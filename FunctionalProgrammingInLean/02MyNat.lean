import Mathlib.Tactic

/-
# Constructing Infinite Types: Natural Numbers

## 1. From Finite to Infinite

In previous worksheets, we worked with finite types. Now, we will build a type that has a
(countably) infinite number of objects: **Natural Numbers**.

We will not use standard digits (0, 1, 2). Instead, we will construct them from scratch.

### A Foundational Definition
Mathematically, we can describe Natural Numbers as the **'smallest'** type that satisfies two rules:
1. It contains a starting object representing 0 (which we call **sifr**).
2. It has an **injective function** (which we call **khalifa**) that takes a number and produces the next one.

Crucially, **sifr** does not belong to the range of **khalifa** (nothing comes before zero).

By "smallest," we mean the type contains *only* the objects generated by these two rules—there is no extra "junk" in the set.


* **sifr**: The end of the chain (Zero).
* **khalifa**: A link that points to the next number (Successor).
-/

inductive MyNat where
| sifr : MyNat
| khalifa : MyNat → MyNat
deriving Repr, DecidableEq

/-
##
When we define a new type, Lean doesn't automatically know how to print it or compare it. `deriving` asks Lean to generate this code for us.

* **`Repr` (Representation)**: Allows `#eval` to print the value as a string (e.g., "khalifa sifr"). Without this, Lean can't show you the result of a computation.
* **`DecidableEq`**: Allows Lean to calculate if two numbers are equal (e.g., `if x = y`). Without this, equality is just a logical statement, not a computable true/false check.

**NOTE** This is not how natural numbers are implemented in Lean for reasons of efficiency of computation, but this is a nice definition to work with, to understand the foundations 'type theoretically'.
-/
namespace MyNat

/-
## Namespace (The Container)
Think of `namespace` as a **surname** or a **folder**.
* It prevents name clashes. Standard Lean has `Nat.add`; we want our own `MyNat.add`.
* Inside `namespace MyNat`, we can just say `add`.
* Outside, we must say `MyNat.add`, unless we use `open MyNat` (which puts us on a "first-name basis").

-/
-- VISUALIZATION:
-- 3 = khalifa (khalifa -(khalifa  sifr))
--

/-
## 2. Recursive Definitions

In the reference file, you used `ring` to calculate. Here, we must define *how* to calculate.
Since we cannot list infinite cases, we use **Recursion**.

We define addition `+₁` by pattern matching on the first argument `m`.
* If `m` is `sifr` (0), the answer is just `n`.
* If `m` is `khalifa k` (k + 1), the answer is the successor of `k + n`.
-/

def my_add (m : MyNat) (n: MyNat) : MyNat :=
match m with
  | sifr => n
  | khalifa k => khalifa (my_add k n)



-- VISUALIZATION:
-- Imagine a stack of plates. To add (khalifa k) + n, we take the top plate (khalifa)
-- off and hold it, then calculate `k + n`. We keep doing this until the stack is empty.
-- Then we put the plates back on.
--

/-
It's your turn. Use `#eval` to compute `1 + 1`.
Recall that `1` is `khalifa sifr`.
-/

-- Replace the line below with your eval command
#eval my_add (khalifa sifr)  (khalifa sifr)

/- ## Infix operation -/

infix:50  " +₁ " => my_add

/- `infix` allows us to define mathematical notation.
* Writing `my_add a b` is tedious.
* `infix:50 " +₁ " => my_add` tells Lean: "When you see `+₁`, treat it as `my_add`."
* The number (`50`) is the **precedence** (Order of Operations). Higher numbers bind tighter (like how `*` beats `+`).
-/

--Check the use of infix below
#eval (khalifa sifr +₁ khalifa sifr)

--In the earlier version of the eval above, replace my_add by +₁ and see if it still works, if it does not see why and revert to original expression

/- We define **multiplication** `·₁` similar to above by pattern matching on the first argument `m`.
* If `m` is `sifr` (0), the answer is just `0`.
* If `m` is `khalifa k` (k + 1), the answer is  of `k · n + n`.
-/

def my_mult (m : MyNat) (n : MyNat) :=
match m with
| sifr => sifr
| khalifa k => ((my_mult k n) +₁ n)

infix:  51 "·₁" => my_mult

--`Exercise: Define a factorial function (recursively) below, you can call it my_factorial`

--evaluate 2 * 3
#eval ((khalifa (khalifa sifr)) ·₁ (khalifa (khalifa (khalifa sifr))))


/-
## 3. Proofs of Programs: The Reflexivity Tactic (`rfl`)

We will now look at how we can prove properties of programs, an exercise useful for program verification . For this, we will consider some of the algebraic properties of addition and multiplication.


One of the earliest proofs you encounter is proving calculation by definition.
Just like `ring` solved equalities for Real numbers, `rfl` (reflexivity) solves equalities
that are true *by definition*.
-/

example : (khalifa sifr +₁ khalifa sifr) = khalifa (khalifa sifr) := by
  rfl

/-
Try it yourself. Prove that $2 + 2 = 4$ using `rfl`.by replacing the sorry
-/

example : ((khalifa (khalifa sifr)) +₁ (khalifa (khalifa sifr))) =
          khalifa (khalifa (khalifa (khalifa sifr))) := by sorry


/- Note that each of the functions we defined above are also programs which run on inputs and produce outputs-/
/-

## 4. Proofs of Programs: Proof by Induction

In `01Rewriting.lean`, we used `rw` to replace equal terms.
To prove a property `P` for *all* natural numbers `n` (infinity), we need a new tool: **Induction**.

This is the Domino Effect:
1.  **Base Case:** Prove the first domino falls (`sifr`).
2.  **Inductive Step:** Prove that IF domino `k` falls, THEN domino `khalifa k` falls.

/--
VISUALIZATION: Proof by Induction (Dominoes)
--------------------------------------------
Goal: Prove property P for ALL numbers.

      [P 0]      [P 1]        [P 2]...
      sifr    (khalifa sifr) (khalifa khalifa sifr)

1. Base Case:
   Push the first domino (Prove P sifr).

2. Inductive Step (The Chain Reaction):
   Prove that IF a domino falls (ih), it knocks down the next one.
   (P k → P (khalifa k))
-/
-/

--

/-
Carefully step through the proof below.
Place your cursor after `induction n with` to see the two goals appear in the Infoview.
-/

lemma right_id_my_nat (n : MyNat) : (n +₁ sifr) = n := by
  induction n with
  | sifr =>
      -- Base Case: We need to prove `sifr +₁ sifr = sifr`.
      -- This is true by definition of `my_add`.
      rfl
  | khalifa k ih =>
     -- Inductive Step:
      -- We assume `ih : k +₁ sifr = k` (The previous domino fell).
      -- We need to prove `khalifa k +₁ sifr = khalifa k`.
      calc
        ((khalifa k) +₁ sifr) = khalifa (k +₁ sifr) := by rfl
        _                   = khalifa k           := by rw [ih]

/-
## 5. Rewriting with the Inductive Hypothesis

In the example above, notice the line `rw [ih]`.
This is exactly like the `rw [h]` you saw in the reference file!
We use the assumption `ih` (that it works for `k`) to prove it for `khalifa k`.

Now try it yourself.
We need to prove we can pull a successor out of the right side of an addition.
You will need to use `rw [ih]` to complete the chain.
-/

lemma right_succ_my_nat (m : MyNat) (n : MyNat) : (n +₁ khalifa m) = khalifa (n +₁ m) := by
  induction n with
  | sifr => rfl
  | khalifa k ih =>
    calc
      (khalifa k +₁ khalifa m) = khalifa (k +₁ khalifa m) := by rfl
      _                        = khalifa (khalifa (k +₁ m)) := by
          -- GOAL: Use the Inductive Hypothesis (ih) here.
          -- Look at your Tactic State to see what `ih` is!
          sorry
      _                        = khalifa (khalifa k +₁ m)   := by rfl

/-
## 6. Calculation Layout

Just like in the earlier files, `calc` blocks help us structure our thoughts.
Use the lemmas we just proved (`right_id_my_nat` and `right_succ_my_nat`) to prove commutativity.

Hint: You will need to use `rw` multiple times.
-/

lemma my_add_commute (m : MyNat) (n : MyNat): (m +₁ n) = (n +₁ m) :=  by
  induction m with
  | sifr =>
      rw [right_id_my_nat]
      rfl
  | khalifa k ih => sorry -- Use an earlier lemma, possibly in reverse

/-
Congratulations! You are now effectively rebuilding the foundations of arithmetic and proved
commutativity from scratch.
-/

--Prove the following:
lemma my_mult_zero (m : MyNat) (n : MyNat): (m ·₁ sifr) = sifr :=  by
  induction m with
  | sifr =>
      sorry
  | khalifa k ih =>
      rw[my_mult]
      sorry

lemma my_mult_left_one (m : MyNat) (n : MyNat): ( khalifa sifr ·₁ m) = m :=  by
  induction m with
  | sifr =>
      sorry
  | khalifa k ih =>
     sorry


lemma my_mult_by_one (m : MyNat) (n : MyNat): (m ·₁ khalifa sifr) = m :=  by
  sorry


/- Prove the following:
1. Multiplication by sifr (zero) on the right side is also zero.
2. Factorial of a number is greater than or equal to the number itself.
3. Feeling more adventures. Prove that multiplication and addition and multiplication in MyNat are associative.

-/
